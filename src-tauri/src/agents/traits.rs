//! Agent trait definitions and shared types
//! Core abstractions for the multi-agent system

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::atomic::Ordering;
use std::time::{Duration, Instant};

/// Result type for agent operations
pub type AgentResult<T> = Result<T, AgentError>;

/// Agent error types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentError {
    /// Failed to process input
    ProcessingError(String),
    /// External service failed (e.g., AI API)
    ServiceError(String),
    /// Invalid state or configuration
    ConfigError(String),
    /// Agent timed out
    Timeout,
    /// Agent was cancelled
    Cancelled,
    /// Rate limit exceeded
    RateLimited(String),
    /// Circuit breaker is open (service temporarily unavailable)
    CircuitOpen(String),
    /// Execution failed (e.g., input simulation or vision analysis failed)
    ExecutionError(String),
    /// Safety violation (caught by safe guards)
    SafetyViolation(String),
}

impl std::fmt::Display for AgentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AgentError::ProcessingError(msg) => write!(f, "Processing error: {}", msg),
            AgentError::ServiceError(msg) => write!(f, "Service error: {}", msg),
            AgentError::ConfigError(msg) => write!(f, "Config error: {}", msg),
            AgentError::Timeout => write!(f, "Agent timed out"),
            AgentError::Cancelled => write!(f, "Agent was cancelled"),
            AgentError::RateLimited(msg) => write!(f, "Rate limited: {}", msg),
            AgentError::CircuitOpen(msg) => write!(f, "Circuit open: {}", msg),
            AgentError::ExecutionError(msg) => write!(f, "Execution error: {}", msg),
            AgentError::SafetyViolation(msg) => write!(f, "Safety violation: {}", msg),
        }
    }
}

impl std::error::Error for AgentError {}

/// A sub-goal generated by the PlannerAgent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubGoal {
    /// Step number in the plan
    pub step: usize,
    /// Description of what to look for
    pub description: String,
    /// Keywords to search/match
    pub keywords: Vec<String>,
    /// Whether this sub-goal has been achieved
    pub achieved: bool,
    /// Confidence that this step is on the right track
    pub confidence: f32,
}

/// Search strategy determined by the planner
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub enum SearchStrategy {
    /// Broad exploration - user is far from goal
    #[default]
    Explore,
    /// Focused search - user is getting closer
    Focus,
    /// Verification - user is very close, verify details
    Verify,
    /// Celebrate - puzzle solved
    Celebrate,
}

/// Agent orchestration mode - consolidates runtime feature toggles
/// Prevents combinatorial explosion of individual boolean flags
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum AgentMode {
    /// Legacy mode: Sequential workflow (Observer → Verifier → Narrator)
    /// No planning, no reflection, no guardrails
    Legacy,
    /// Standard mode: Planning enabled, guardrails enabled, no reflection
    /// Good balance of intelligence and performance
    #[default]
    Standard,
    /// Full mode: All features enabled (planning, reflection, guardrails)
    /// Highest quality but slower due to reflection iterations
    Full,
    /// Minimal mode: Only guardrails enabled
    /// For maximum performance with basic safety
    Minimal,
}

impl AgentMode {
    /// Check if intelligent planning is enabled in this mode
    pub fn use_planning(&self) -> bool {
        matches!(self, AgentMode::Standard | AgentMode::Full)
    }

    /// Check if reflection is enabled in this mode
    pub fn use_reflection(&self) -> bool {
        matches!(self, AgentMode::Full)
    }

    /// Check if guardrails are enabled in this mode
    pub fn use_guardrails(&self) -> bool {
        matches!(
            self,
            AgentMode::Standard | AgentMode::Full | AgentMode::Minimal
        )
    }

    /// Get mode from individual flags (for backward compatibility)
    pub fn from_flags(intelligent: bool, reflection: bool, guardrails: bool) -> Self {
        match (intelligent, reflection, guardrails) {
            (true, true, true) => AgentMode::Full,
            (true, false, true) => AgentMode::Standard,
            (false, false, true) => AgentMode::Minimal,
            (false, false, false) => AgentMode::Legacy,
            // Default to Standard for unusual combinations
            _ => AgentMode::Standard,
        }
    }
}

/// Planning context generated by PlannerAgent
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct PlanningContext {
    /// Generated sub-goals for the current puzzle
    pub sub_goals: Vec<SubGoal>,
    /// Primary keywords to look for (derived from puzzle analysis)
    pub primary_keywords: Vec<String>,
    /// Secondary/related keywords
    pub secondary_keywords: Vec<String>,
    /// Current search strategy
    pub strategy: SearchStrategy,
    /// Estimated puzzle difficulty (0.0 = easy, 1.0 = hard)
    pub difficulty: f32,
    /// Number of times the plan has been revised
    pub revision_count: usize,
    /// Last failed approach (for self-correction)
    pub failed_approaches: Vec<String>,
}

/// Reflection feedback from CriticAgent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReflectionFeedback {
    /// Whether the output passed validation
    pub approved: bool,
    /// Critique/feedback message
    pub critique: String,
    /// Specific issues found
    pub issues: Vec<String>,
    /// Suggestions for improvement
    pub suggestions: Vec<String>,
    /// Safety score (0.0 = unsafe, 1.0 = safe)
    pub safety_score: f32,
    /// Quality score (0.0 = poor, 1.0 = excellent)
    pub quality_score: f32,
}

impl Default for ReflectionFeedback {
    fn default() -> Self {
        Self {
            approved: true,
            critique: String::new(),
            issues: Vec::new(),
            suggestions: Vec::new(),
            safety_score: 1.0,
            quality_score: 1.0,
        }
    }
}

/// Context passed to agents during execution
#[derive(Debug, Clone, Default)]
pub struct AgentContext {
    /// Current URL being viewed
    pub current_url: String,
    /// Current page title
    pub current_title: String,
    /// Current page content (text)
    pub page_content: String,
    /// Current puzzle ID
    pub puzzle_id: String,
    /// Current puzzle clue
    pub puzzle_clue: String,
    /// Target URL pattern for current puzzle
    pub target_pattern: String,
    /// Current proximity score
    pub proximity: f32,
    /// Ghost personality/mood
    pub ghost_mood: String,
    /// Hints already revealed
    pub hints_revealed: usize,
    /// Available hints
    pub hints: Vec<String>,
    /// Custom metadata
    pub metadata: HashMap<String, String>,

    // === NEW: Planning & Reflection Artifacts ===
    /// Planning context from PlannerAgent (sub-goals, keywords, strategy)
    pub planning: PlanningContext,
    /// Last reflection feedback from CriticAgent
    pub last_reflection: Option<ReflectionFeedback>,
    /// Number of reflection iterations performed
    pub reflection_iterations: usize,
    /// Previous narrator outputs (for reflection loop)
    pub previous_outputs: Vec<String>,
}

/// Output from an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentOutput {
    /// Agent name that produced this output
    pub agent_name: String,
    /// Main result/response
    pub result: String,
    /// Confidence score (0.0 - 1.0)
    pub confidence: f32,
    /// Additional data
    pub data: HashMap<String, serde_json::Value>,
    /// Suggested next action
    pub next_action: Option<NextAction>,
}

/// Suggested next action from an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NextAction {
    /// Continue to next agent
    Continue,
    /// Repeat current operation
    Retry,
    /// Puzzle was solved
    PuzzleSolved,
    /// Show specific hint
    ShowHint(usize),
    /// Generate new puzzle
    GeneratePuzzle,
    /// Stop processing
    Stop,
    /// Abort the entire pipeline (security threat)
    Abort,
    /// Pause and wait for user confirmation
    PauseForConfirmation,
}

/// Core agent trait - all agents implement this
///
/// # Thread Safety Requirements
/// Agents must be `Send + Sync` because they are shared across async tasks:
/// - `Send`: The agent can be transferred between threads
/// - `Sync`: The agent can be referenced from multiple threads simultaneously
///
/// Implementors must ensure all internal state is thread-safe. Common patterns:
/// - Use `Arc<Mutex<T>>` or `Arc<RwLock<T>>` for mutable shared state
/// - Prefer immutable state where possible
/// - Use atomic types for counters and flags
///
/// # Lifecycle Hooks (Best Practice)
/// Agents can optionally implement lifecycle methods:
/// - `initialize()`: Called once when the orchestrator starts
/// - `shutdown()`: Called when the orchestrator is shutting down
/// - `health_check()`: Called periodically to check agent health
#[async_trait]
pub trait Agent: Send + Sync {
    /// Get agent name
    fn name(&self) -> &str;

    /// Get agent description
    fn description(&self) -> &str;

    /// Process context and produce output
    async fn process(&self, context: &AgentContext) -> AgentResult<AgentOutput>;

    /// Check if agent can handle this context
    fn can_handle(&self, context: &AgentContext) -> bool {
        // Default: can handle any context
        let _ = context;
        true
    }

    /// Reset agent state
    fn reset(&mut self) {
        // Default: no state to reset
    }

    // =========================================================================
    // Lifecycle Hooks (Optional - Best Practice from Anthropic's Agent Guide)
    // =========================================================================

    /// Initialize the agent (called once at startup)
    /// Override to perform async initialization like warming up caches,
    /// checking service connectivity, etc.
    async fn initialize(&self) -> AgentResult<()> {
        Ok(())
    }

    /// Shutdown the agent gracefully (called at orchestrator shutdown)
    /// Override to clean up resources, flush logs, etc.
    async fn shutdown(&self) -> AgentResult<()> {
        Ok(())
    }

    /// Health check (called periodically by orchestrator)
    /// Returns true if the agent is healthy and ready to process requests
    fn health_check(&self) -> bool {
        true
    }

    /// Get agent version for A/B testing and debugging
    fn version(&self) -> &str {
        "1.0.0"
    }

    /// Get agent priority for ordering in workflows
    fn priority(&self) -> AgentPriority {
        AgentPriority::Normal
    }
}

/// Agent priority for ordering
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum AgentPriority {
    Critical = 0,
    High = 1,
    Normal = 2,
    Low = 3,
    Background = 4,
}

// =============================================================================
// Rate Limiter (Best Practice: Protect against runaway costs)
// =============================================================================

/// Simple token bucket rate limiter for agent calls
pub struct RateLimiter {
    /// Maximum tokens (calls) in the bucket
    max_tokens: u32,
    /// Current tokens available
    tokens: std::sync::atomic::AtomicU32,
    /// Refill rate (tokens per second)
    refill_rate: f32,
    /// Last refill timestamp
    last_refill: std::sync::Mutex<Instant>,
}

impl RateLimiter {
    /// Create a new rate limiter
    /// - `max_calls_per_minute`: Maximum calls allowed per minute
    pub fn new(max_calls_per_minute: u32) -> Self {
        Self {
            max_tokens: max_calls_per_minute,
            tokens: std::sync::atomic::AtomicU32::new(max_calls_per_minute),
            refill_rate: max_calls_per_minute as f32 / 60.0,
            last_refill: std::sync::Mutex::new(Instant::now()),
        }
    }

    /// Try to acquire a token. Returns true if allowed, false if rate limited.
    pub fn try_acquire(&self) -> bool {
        // Refill tokens based on elapsed time
        if let Ok(mut last) = self.last_refill.lock() {
            let elapsed = last.elapsed();
            let tokens_to_add = (elapsed.as_secs_f32() * self.refill_rate) as u32;

            if tokens_to_add > 0 {
                let current = self.tokens.load(Ordering::Relaxed);
                let new_tokens = (current + tokens_to_add).min(self.max_tokens);
                self.tokens.store(new_tokens, Ordering::Relaxed);
                *last = Instant::now();
            }
        }

        // Try to consume a token
        loop {
            let current = self.tokens.load(Ordering::SeqCst);
            if current == 0 {
                return false;
            }
            if self
                .tokens
                .compare_exchange(current, current - 1, Ordering::SeqCst, Ordering::SeqCst)
                .is_ok()
            {
                return true;
            }
        }
    }

    /// Get remaining tokens
    pub fn remaining(&self) -> u32 {
        self.tokens.load(Ordering::Relaxed)
    }

    /// Get time until next token is available (approximate)
    pub fn time_until_available(&self) -> Duration {
        if self.tokens.load(Ordering::Relaxed) > 0 {
            Duration::ZERO
        } else {
            Duration::from_secs_f32(1.0 / self.refill_rate)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rate_limiter_basic() {
        let limiter = RateLimiter::new(5); // 5 per minute for testing

        // Should allow 5 immediate calls
        for _ in 0..5 {
            assert!(limiter.try_acquire());
        }

        // 6th call should be rejected
        assert!(!limiter.try_acquire());
        assert_eq!(limiter.remaining(), 0);
    }

    #[test]
    fn test_agent_mode_flags() {
        assert!(AgentMode::Full.use_planning());
        assert!(AgentMode::Full.use_reflection());
        assert!(AgentMode::Full.use_guardrails());

        assert!(AgentMode::Standard.use_planning());
        assert!(!AgentMode::Standard.use_reflection());
        assert!(AgentMode::Standard.use_guardrails());

        assert!(!AgentMode::Minimal.use_planning());
        assert!(!AgentMode::Minimal.use_reflection());
        assert!(AgentMode::Minimal.use_guardrails());

        assert!(!AgentMode::Legacy.use_planning());
        assert!(!AgentMode::Legacy.use_reflection());
        assert!(!AgentMode::Legacy.use_guardrails());
    }

    #[test]
    fn test_agent_mode_from_flags() {
        assert_eq!(AgentMode::from_flags(true, true, true), AgentMode::Full);
        assert_eq!(
            AgentMode::from_flags(true, false, true),
            AgentMode::Standard
        );
        assert_eq!(
            AgentMode::from_flags(false, false, true),
            AgentMode::Minimal
        );
        assert_eq!(
            AgentMode::from_flags(false, false, false),
            AgentMode::Legacy
        );
    }

    #[test]
    fn test_agent_error_display() {
        assert_eq!(
            AgentError::RateLimited("too many calls".to_string()).to_string(),
            "Rate limited: too many calls"
        );
        assert_eq!(
            AgentError::CircuitOpen("LLM unavailable".to_string()).to_string(),
            "Circuit open: LLM unavailable"
        );
    }
}
