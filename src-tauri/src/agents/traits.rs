//! Agent trait definitions and shared types
//! Core abstractions for the multi-agent system

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Result type for agent operations
pub type AgentResult<T> = Result<T, AgentError>;

/// Agent error types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentError {
    /// Failed to process input
    ProcessingError(String),
    /// External service failed (e.g., AI API)
    ServiceError(String),
    /// Invalid state or configuration
    ConfigError(String),
    /// Agent timed out
    Timeout,
    /// Agent was cancelled
    Cancelled,
}

impl std::fmt::Display for AgentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AgentError::ProcessingError(msg) => write!(f, "Processing error: {}", msg),
            AgentError::ServiceError(msg) => write!(f, "Service error: {}", msg),
            AgentError::ConfigError(msg) => write!(f, "Config error: {}", msg),
            AgentError::Timeout => write!(f, "Agent timed out"),
            AgentError::Cancelled => write!(f, "Agent was cancelled"),
        }
    }
}

impl std::error::Error for AgentError {}

/// A sub-goal generated by the PlannerAgent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubGoal {
    /// Step number in the plan
    pub step: usize,
    /// Description of what to look for
    pub description: String,
    /// Keywords to search/match
    pub keywords: Vec<String>,
    /// Whether this sub-goal has been achieved
    pub achieved: bool,
    /// Confidence that this step is on the right track
    pub confidence: f32,
}

/// Search strategy determined by the planner
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub enum SearchStrategy {
    /// Broad exploration - user is far from goal
    #[default]
    Explore,
    /// Focused search - user is getting closer
    Focus,
    /// Verification - user is very close, verify details
    Verify,
    /// Celebrate - puzzle solved
    Celebrate,
}

/// Agent orchestration mode - consolidates runtime feature toggles
/// Prevents combinatorial explosion of individual boolean flags
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum AgentMode {
    /// Legacy mode: Sequential workflow (Observer → Verifier → Narrator)
    /// No planning, no reflection, no guardrails
    Legacy,
    /// Standard mode: Planning enabled, guardrails enabled, no reflection
    /// Good balance of intelligence and performance
    #[default]
    Standard,
    /// Full mode: All features enabled (planning, reflection, guardrails)
    /// Highest quality but slower due to reflection iterations
    Full,
    /// Minimal mode: Only guardrails enabled
    /// For maximum performance with basic safety
    Minimal,
}

impl AgentMode {
    /// Check if intelligent planning is enabled in this mode
    pub fn use_planning(&self) -> bool {
        matches!(self, AgentMode::Standard | AgentMode::Full)
    }

    /// Check if reflection is enabled in this mode
    pub fn use_reflection(&self) -> bool {
        matches!(self, AgentMode::Full)
    }

    /// Check if guardrails are enabled in this mode
    pub fn use_guardrails(&self) -> bool {
        matches!(self, AgentMode::Standard | AgentMode::Full | AgentMode::Minimal)
    }

    /// Get mode from individual flags (for backward compatibility)
    pub fn from_flags(intelligent: bool, reflection: bool, guardrails: bool) -> Self {
        match (intelligent, reflection, guardrails) {
            (true, true, true) => AgentMode::Full,
            (true, false, true) => AgentMode::Standard,
            (false, false, true) => AgentMode::Minimal,
            (false, false, false) => AgentMode::Legacy,
            // Default to Standard for unusual combinations
            _ => AgentMode::Standard,
        }
    }
}

/// Planning context generated by PlannerAgent
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct PlanningContext {
    /// Generated sub-goals for the current puzzle
    pub sub_goals: Vec<SubGoal>,
    /// Primary keywords to look for (derived from puzzle analysis)
    pub primary_keywords: Vec<String>,
    /// Secondary/related keywords
    pub secondary_keywords: Vec<String>,
    /// Current search strategy
    pub strategy: SearchStrategy,
    /// Estimated puzzle difficulty (0.0 = easy, 1.0 = hard)
    pub difficulty: f32,
    /// Number of times the plan has been revised
    pub revision_count: usize,
    /// Last failed approach (for self-correction)
    pub failed_approaches: Vec<String>,
}

/// Reflection feedback from CriticAgent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReflectionFeedback {
    /// Whether the output passed validation
    pub approved: bool,
    /// Critique/feedback message
    pub critique: String,
    /// Specific issues found
    pub issues: Vec<String>,
    /// Suggestions for improvement
    pub suggestions: Vec<String>,
    /// Safety score (0.0 = unsafe, 1.0 = safe)
    pub safety_score: f32,
    /// Quality score (0.0 = poor, 1.0 = excellent)
    pub quality_score: f32,
}

impl Default for ReflectionFeedback {
    fn default() -> Self {
        Self {
            approved: true,
            critique: String::new(),
            issues: Vec::new(),
            suggestions: Vec::new(),
            safety_score: 1.0,
            quality_score: 1.0,
        }
    }
}

/// Context passed to agents during execution
#[derive(Debug, Clone, Default)]
pub struct AgentContext {
    /// Current URL being viewed
    pub current_url: String,
    /// Current page title
    pub current_title: String,
    /// Current page content (text)
    pub page_content: String,
    /// Current puzzle ID
    pub puzzle_id: String,
    /// Current puzzle clue
    pub puzzle_clue: String,
    /// Target URL pattern for current puzzle
    pub target_pattern: String,
    /// Current proximity score
    pub proximity: f32,
    /// Ghost personality/mood
    pub ghost_mood: String,
    /// Hints already revealed
    pub hints_revealed: usize,
    /// Available hints
    pub hints: Vec<String>,
    /// Custom metadata
    pub metadata: HashMap<String, String>,
    
    // === NEW: Planning & Reflection Artifacts ===
    
    /// Planning context from PlannerAgent (sub-goals, keywords, strategy)
    pub planning: PlanningContext,
    /// Last reflection feedback from CriticAgent
    pub last_reflection: Option<ReflectionFeedback>,
    /// Number of reflection iterations performed
    pub reflection_iterations: usize,
    /// Previous narrator outputs (for reflection loop)
    pub previous_outputs: Vec<String>,
}

/// Output from an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentOutput {
    /// Agent name that produced this output
    pub agent_name: String,
    /// Main result/response
    pub result: String,
    /// Confidence score (0.0 - 1.0)
    pub confidence: f32,
    /// Additional data
    pub data: HashMap<String, serde_json::Value>,
    /// Suggested next action
    pub next_action: Option<NextAction>,
}

/// Suggested next action from an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NextAction {
    /// Continue to next agent
    Continue,
    /// Repeat current operation
    Retry,
    /// Puzzle was solved
    PuzzleSolved,
    /// Show specific hint
    ShowHint(usize),
    /// Generate new puzzle
    GeneratePuzzle,
    /// Stop processing
    Stop,
}

/// Core agent trait - all agents implement this
///
/// # Thread Safety Requirements
/// Agents must be `Send + Sync` because they are shared across async tasks:
/// - `Send`: The agent can be transferred between threads
/// - `Sync`: The agent can be referenced from multiple threads simultaneously
///
/// Implementors must ensure all internal state is thread-safe. Common patterns:
/// - Use `Arc<Mutex<T>>` or `Arc<RwLock<T>>` for mutable shared state
/// - Prefer immutable state where possible
/// - Use atomic types for counters and flags
#[async_trait]
pub trait Agent: Send + Sync {
    /// Get agent name
    fn name(&self) -> &str;

    /// Get agent description
    fn description(&self) -> &str;

    /// Process context and produce output
    async fn process(&self, context: &AgentContext) -> AgentResult<AgentOutput>;

    /// Check if agent can handle this context
    fn can_handle(&self, context: &AgentContext) -> bool {
        // Default: can handle any context
        let _ = context;
        true
    }

    /// Reset agent state
    fn reset(&mut self) {
        // Default: no state to reset
    }
}

/// Agent priority for ordering
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum AgentPriority {
    Critical = 0,
    High = 1,
    Normal = 2,
    Low = 3,
    Background = 4,
}
